멤버 함수의 재정의(Overriding)
=============================
클래스 라이브러리는 계층구조적으로 만들어진 클래스들의 모임이다.

## 함수의 재정의에 의한 기능 수정
상속성과 더불어 클래스 라이브러리의 유용성을 한 층 더 증대 시켜주는 C++의 특징은 멤버 함수의 재정의 기능이다. 이미 만들어진 클래스에 원하는 모든 기능이 다 들어 있는데, 그 중에 하나가 부족하거나 추가할께있을 경우 그 클래스를 그대로 쓸 수 없다. 이럴 때는 이 클래스에서 상속을 받아 파생 클래스를 만들고, 마음에 안드는 함수만 고쳐서 사용할 수 있다.

point 클래스에 x,y좌표 외에 z좌표를 추가하여 3차원 공간상의 점의 좌표를 저장할 수 있는 클래스를 만들것이다.
```
class Point
{
  public:
    int m_nX, m_nY;//x, y 좌표
    ...
};
```
Point 클래스에 이미 x, y 좌표를 저장하는 기능이 마련되어 있기 때문에 여기서 상속을 받으면 z좌표를 저장하는 기능만 추가해 주면 된다.

```
class Point3D : public Point
{
  public:
    int m_nZ; //z좌표
};
```
위와 같이 하면 Point3D클래스는 Point클래스에서 모든 기능이 상속된다. 기반 클래스로 부터 받은 기능들을 대부분 사용할 수 있지만, 어떤 것은 그대로 사용할 수 없다.
예를 들면, Point 클래스의 show 함수는 x, y 좌표를 화면에 출력하도록 구현되어 있다. 그런데 Point3D 클래스는 z좌표까지 화면에 출력해 주어야 한다. 그래서 기반클래스의 show함수를 그대로 사용할 수 없다. 이런 경우, Point3D함수에서 용도에 맞도록 Show 함수를 다시 정의 한다.

```
class Point3D : public Point
{
  public:
    int m_nZ; //z좌표
    void show();//show 함수의 재정의
};

void Point3D::show()
{
  cout << "Z=" << m_nZ << ", X=" << m_nX << ", Y=" << m_nY << "\n";
}
```
위와 같이 기반 클래스에 이미 존재하는 함수를 파생 클래스에서 다시 선언하고, 구현 하는 것을 함수를 재정의(Overriding)라고 한다. 기반 클래스에 존재하는 함수를 파생 클래스에서 재정의 하면 기반클래스에서 정의된 함수가 무시되고, 파생클래스에 새로 정의된 함수가 동작을 하게 된다.

## 함수 재정의에 의한 기능 추가
이번에는 기반 클래스의 기능이 완전히 맘에 안드는 것은 아니지만 기능이 부족하여 추가를 해야 하는 경우에는 기반 클래스의 함수를 재정의 하면 기반 클래스에 정의된 함수가 무시되고, 파생 클래스에서 새로 정의한 함수가 동작을 하게 된다. 이 때, 기반 클래스에 정의되어 있는 함수의 기능을 완전히 무시하지 않고, 기존의 것에 새로운 기능을 약간 추가만 할 경우에 사용한다.

```
void Point3D::show()
{
  cout << "Z=" << m_nZ << ", "; // 새로운 기능 추가
  Point::show(); // 기반 클래스의 show() 함수를 호출
}
```
위와 같이 파생 클래스에서 함수를 재정의 할 때, 기반 클래스의 기능을 완전히 무시하는 경우보다는 기존의 기능을 그대로 유지하면서, 원하는 기능을 조금 추가하는 식으로 프로그래밍 하게되는 경우가 더 많다.

## 오버로딩(Overloding)과 재정의(Overriding)
Overloding과 Overriding은 비슷하게 생겨서 혼동하기 쉽다. 하지만 전혀 다른 의미를 가지고 있다.

### 오버로딩
하나의 함수명에 비슷한 기능을 하면서 넘겨 받는 매개변수가 서로 다른 함수를 두개 이상 정의하는 것을 말한다.

```
int Add(int a, int b)
{
  return a+b;
}
```
위는 int형 매개변수, 아래는 double형 매개변수로 선언되어 있다.

```
double Add(double a, double b)
{
  return a+b;
}
```
위의 두 함수는 유효한 함수로 사용된다. 두 함수 중 어떤 함수가 호출될 것인지는 매개변수 값에 의해 결정된다. 즉, 똑같은 Add 함수를 호출해도 어떤 매개변수를 사용해서 호출하느냐에 따라서 실제로 호출되는 함수가 달라진다.

```
void main()
{
  int i=2, j=7;
  double k=5, l=9;

  a = Add(i, j); //int Add(int a, int b); 함수 호출
  b = Add(k, l); // double Add(double a, double b) 함수 호출  
}
```
함수를 오버로딩 하면 같은 이름의 함수 여러 개가 동시에 사용되는 것이다. 이 함수들은 매개 변수의 타입에 따라 구별이되므로, 오버로딩 된 함수들은 반드시 매개변수의 타입이 달라 서로 구별 가능하다.

### 오버라이딩(재정의)
기반 클래스에 이미 만들어져 있는 함수의 기능이 마음에 안들어서, 파생  클래스에 서 그 기능을 재정의하려고 할 때 사용된다. 즉, 기반 클래스에 정의되어 있는 어떤 함수를 무시하고, 파생 클래스에서 그 함수를 다시 만드는 것이 재정의이다. 그래서 재정의 할 때는 기반 클래스에 만들어져 있는 함수와 파생 클래스에서 재정의 한 함수명과 매개변수의 타입이 완전히 똑같아서 서로 구별 할 수 없어야 한다. 그렇게 해야만이 기반 클래스에 정의되어 있는 함수가 무시되고, 파생 클래스에 새로 정의한 함수가 동작하게 된다. 만약 재정의 하려고 함수를 만들었는데 이것이 기반 클래스에 있는 함수와 매개변수의 타입이 조금이라도 다르면, 이것은 재정의가 아니라 오버로딩으로 간주된다.

연산자 오버로딩(Operator Overloding)
==============
연산자 오버로딩은 연산자를 함수처럼 정의해서 사용하는 c++의 좋은 기능이다.

__ex)__

```
int a, b=1, c=2;
a = b + c;
```

이러한 연산을 함수로 구현이 가능하다.

```
int a, b=1, c=2;
a = Add(b,c);

int Add(int x, int y)
{
  return x+y;
}
```
위와 같이 연산자를 함수로 구현하는 것을 연산자 오버로딩이라고 한다. 반대로 연산자를 이용해서 함수의 기능을 수행하도록 만들 수 있다.


## 연산자의 종류
연산자 종류는 크게 세 가지로 나누어 볼 수 있다.
* 단항 연산자
  - 전위형
  - 후위형
* 이항 연산자

### 단항 연산자
오퍼랜드(연산 대상이 되는 수)가 몇 개 필요 하느냐에 따라 단항 연산자와 이항 연산자로 나눌 수 있다. 연산을 하는데, 하나의 오퍼랜드가 필요한 연산자를 단항 연산자라고 한다. 연산자가 오퍼랜드보다 앞에 나오는 것을 전위형 연산자라고 하고, 연산자가 오퍼랜드 뒤에 나오는 것을 후위형 연산자라고 한다.

```
++a;
a++;
```

### 이항 연산자
연산을 하는데, 두개의 오퍼랜드가 필요한 연산자를 이항 연산자라고 한다. 사칙 연산을 하는 +, -, x, / 은 모두 이항 연산자이다. a + b, a - b, a * b, a / b와 같이 연산을 수행하기 위해서는 두개의 오퍼랜드가 필요하기 때문이다. 치환 연산자 '='도 이항 연산자이다. 왜냐하면 a = b;에서 오퍼랜드가 a, b 두개가 사용되기 때문이다.

__이러한 각 종류의 연산장 따라 연산자 오버로딩을 하는 방법이 각기 다르다. 그러면 각 경우에 대해 연산자 오버로딩을 하는 방법에 대해 알아볼 것 이다.__

## 전위형 단항 연산자
지금까지는 x, y좌표를 각각 1씩 증가시키는 기능을 하는 Icrease()라는 간단한기능을 하는 함수를 Point 클래스의 멤버함수로 추가하고, 이를 사용하는 과정을 보았다.

```
void main()
{
  Point p;
  p.SetPosition(10,10);
  ++p;
  p.show();
}
```
x, y 좌표를 각각 1씩 증가시키는 기능을 하는 Increase 라는 함수를 호출하는 대신에 ++라는 연산자를 사용하였다. 이러한 경우 연산자를 사용하면, 간결하게 표현 할 수 있다. 연산자 오버로딩 기능을 이용하면 함수를 호출하는 대신에 연산자 표현을 쓸 수 있다. ++ 연산자가 Increase 함수와 같은 기능을 하도록하려면 다음과 같이 한다.

첫째, Point.h파일을 열어, ++연산자를 멤버 함수로 선언해 준다. 이때 함수 명은 operator라는 키워드에 연산자를 붙여서 쓰면 그 연산자가 함수처럼 동작하게 된다. operator는 C++에서 사용되는 키워드이다.
```
class Point
{
  void operator++();//멤버 함수 선언
  ...
}
```

둘째, Point.cpp파일을 열어, 다음과 같이 연산자 함수를 구현해 준다.
```
void Point::operator++()
{
  m_nX++;
  m_nY++;
}
```
위와 같이 하면 Increase라는 함수를 호출하는 대신에 ++라는 연산자 표현을 이용하여 같은 기능을 하도록 할 수 있다. 달라진 것은 Increase라는 함수명을 쓰는대신 operator++라는 함수명을 쓴다.

operator++함수를 호출하려면 기존 함수를 사용할 때와 다르게 사용해야한다.
```
p.operator++();// 기존의 함수 호출 방법
++p; //operator++함수 호출 방법
```

++ 연산자를 보다 완벽하게 정의하려면, 연산자 함수를 정의하는데 좀 더 신경을 써야 한다.
```
Point p,q;
q= ++p;
```

위와 같은 경우 함수 operator++()는 반환값이 없기 때문에, q에 아무 값도 대입이 안된다. 이와 같은 상황을 대처하려면 다음과 같이 연산자 함수가 현재 인스턴스와 같은 값을 갖는 인스턴스를 반환해주면 된다.
```
void Point::operator++()
{
  ++m_nX;
  ++m_nY;

  Point newPoint;
  newPoint.m_nX = m_nX;
  newPoint.m_nY = m_nY;
  return newPoint;
}
```

주어진 값을 이용하여 초기화를 수행하는 생성자 함수를 만든다.
```
Point::Point(int nX, int nY)
{
  m_nX = nX;
  m_nY = nY;
}
```
위와 같이 생성자 함수를 만들어 놓으면 간략하게 표현이 가능하다.
```
Point Point::operator++()
{
  return Point(++m_nX, ++m_nY);
}
```

## 후위형 단항 연산자
a++은 operator++(int)이라는 함수를 호출한다. 즉, operator++이라는 이름의 함수를 호출하기는 하지만 매개변수를 하나 넘겨 받는 함수를 호출한다. 이 매개변수는 실제로 의미있는 매개변수가 넘어오는 것은 아니다. 단지 ++a이라는 문장이 호출하는 함수 operator++()와 구별하기 위해서 a++이라는 문장을 매개변수 하나 넘겨 받은 operator++(int)이라는 함수를 호출하는 것으로 약속한 것이다.

__정리__
전위형 : 매개변수를 넘겨받지 않는 연산자 함수이다. //++a; operator++()

후위형 : 한 개의 무의미한 매개변수를 넘겨받는 연산자 함수이다. //a++; operator++(int)


## 이항 연산자
이항 연산자는 a=b+c;라는 문장은 인스턴스 b에 대해서 operator+라는 함수를 호출하면서, 인스턴스 c를 이 함수의 매개변수로 넘겨준다. 연산의 결과를 a에 넘겨주도록 하기 위해서는 연산자 함수 operator+는 연산의 결과를 반환해 줘야 한다.
```
Point Point::operator+(Point &point)
{
  Point temp;
  temp.m_nX = m_nX+point.m_nX;
  temp.m_nY = m_nY+point.m_nY;
  return temp;
}
```
위의 코드에서는 m_nX, m_nY가 각각 세개가 나온다. 그냥 m_nX, temp.m_nX, point.m_nX 세개가 각각 뭘 지칭하는지 구별할 수 있어야한다. 구별할 수 있다면 인스턴스를 확실히 이해한 것이다.

## 연산자 오버로딩의 규칙
연산자 오버로딩을 할 때에는 반드시 지켜야 할 규칙이 있다. 다음 열거된 규칙을 준수하는 범위 내에서 자유롭게 연산자 함수를 정의하여 사용할 수 있다.

### 연산자 함수로 정의될 수 있는 연산자
```
,
!=
%
%=
&
&&
&=
*
*=
+
+=
–
–=
–>
–>*
/
/=
<
<<
<<=
<=
=
==
>
>=
>>
>>=
^
^=
|
||
NEW
delete
```

### 연산자로 정의될 수 없는 연산자
```
.
```
구조체나 클래스의 멤버를 지정한다.

```
*
```
구조체나 클래스에서 포인터로가지고 있는 멤버를 지정한다.(곱셈연산자 x)

```
::
```
전역 변수를 참조한다.

```
?:
```
주어진 조건에 따라 다른 작업을 수행한다.
